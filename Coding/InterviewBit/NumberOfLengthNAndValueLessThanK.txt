Link: https://www.interviewbit.com/problems/numbers-of-length-n-and-value-less-than-k/

Question: Given a set of digits (A) in sorted order, find how many numbers of length B are possible whose value is less than number C.
NOTE: All numbers can only have digits from the given set.  

Approach: Let us try to solve for all the possible cases.
Let d be size of A.

Case 1: If B is greater than length of C or d is 0 then no such number is possible.

Case 2: If B is smaller than length of C then all the possible combination of digits of length B are valid.

Generate all such B digit numbers.
For the first position we can’t have 0 and for ther rest of (B - 1) position we can have all d possible digits.
Hence, Answer = d B if A contains 0 else (d-1) * ( d )(B-1)

Case 3: If B is equal to length of C
Construct digit array of C ( call it as digit[]).

Let First(i) be a number formed by taking first i digits of it.
Let lower[i] denote number of elements in A which are smaller than i.
It can be easily computed by idea similar to prefix sum.

For example:

First(2) of 423 is 42. 
If  A =  [ 0, 2] then lower[0] = 0, lower[0] = 0, lower[1]  = 1,  lower[2] = 1, lower[3] = 2  
Generate B digit numbers by dynamic programming. Let say dp[i] denotes the total numbers of length i which are less than first i digits of C.

Elements in dp[i] can be generated by two cases :

i) For all the Numbers whose First(i - 1) is less than First (i-1) of C, we can put any digit at i’th index.
Hence, dp[i] += (dp[i-1] * d)

ii) For all the Numbers whose First (i - 1) is same as First (i - 1) of C, we can only put those digits which are smaller than digit[i] .

Hence , dp[i] += lower[digit[i]]

Final answer will be dp[B]

Remark:
For first index don’t include 0 if B is not 1 and dp[0] will be 0.

Time Complexity = O(B)

Solution: 

public class Solution {
    public int solve(ArrayList<Integer> A, int B, int C) {
        int cSize = (int) Math.log10(C) + 1;
        int n = A.size();
        if (cSize < B || n == 0) return 0;
        boolean hasZero = A.get(0) == 0;
        if (cSize > B) return (B > 1 && hasZero ? n - 1 : n) * (int) Math.pow(n, B - 1);
        // B == cSize
        int pow10 = (int) Math.pow(10, B - 1), count = 0;
        for(int i = B; i > 0; i--) {
            int target = C / pow10, j;
            C %= pow10;
            pow10 /= 10;
            for(j = 0; j < n; j++) {
                if (A.get(j) >= target) break;
            }
            count += (B > 1 && i == B && hasZero ? j - 1 : j) * (int) Math.pow(n, i - 1);
            if (j == n || A.get(j) > target) break;
        }
        return count;
    }
}

